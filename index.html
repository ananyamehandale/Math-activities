<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>Factors of 12</title>
Â  Â  <script src="https://cdn.tailwindcss.com"></script>

Â  Â  Â  Â  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" xintegrity="sha384-GvrDXHnZaH4W78Q9Rk+B5Wd8JjBwB9Z2Jc0V2YF8g9W9/1aD3UvA0vP4Z2T4" crossorigin="anonymous">
Â  Â  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" xintegrity="sha384-5f5n8pY2h/1aD3UvA0vP4Z2T4" crossorigin="anonymous"></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" xintegrity="sha384-qfX0D/7/0tK2G2F8g9W9/1aD3UvA0vP4Z2T4" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

Â  Â  <style>
Â  Â  Â  Â  /* Custom Styles for Grid and Dragging */
Â  Â  Â  Â  .grid-container {
Â  Â  Â  Â  Â  Â  display: grid;
Â  Â  Â  Â  Â  Â  grid-template-columns: repeat(12, 50px);
Â  Â  Â  Â  Â  Â  grid-template-rows: repeat(12, 50px);
Â  Â  Â  Â  Â  Â  border: 2px solid #374151;
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
Â  Â  Â  Â  }
Â  Â  Â  Â  .grid-cell {
Â  Â  Â  Â  Â  Â  border: 1px solid rgba(100, 100, 100, 0.2);
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- TILE SOURCE STYLES (Simplified to just selection) --- */
Â  Â  Â  Â  .tile-option-wrapper {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  gap: 4px; /* Space between tile and text */
Â  Â  Â  Â  }
Â  Â  Â  Â  .draggable-tile-source {
Â  Â  Â  Â  Â  Â  cursor: pointer; /* Change from grab to pointer for click selection */
Â  Â  Â  Â  Â  Â  transition: transform 0.1s ease;
Â  Â  Â  Â  Â  Â  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  Â  Â  border: 1px solid rgba(0, 0, 0, 0.1); 
Â  Â  Â  Â  Â  Â  display: grid; 
Â  Â  Â  Â  Â  Â  grid-template-columns: var(--tile-grid-template);
Â  Â  Â  Â  Â  Â  grid-template-rows: var(--tile-grid-template);
Â  Â  Â  Â  }
Â  Â  Â  Â  .draggable-tile-source:hover {
Â  Â  Â  Â  Â  Â  transform: scale(1.05);
Â  Â  Â  Â  }
Â  Â  Â  Â  .tile-option-disabled {
Â  Â  Â  Â  Â  Â  opacity: 0.3;
Â  Â  Â  Â  Â  Â  cursor: not-allowed !important;
Â  Â  Â  Â  }
Â  Â  Â  Â  .tile-option-selected {
Â  Â  Â  Â  Â  Â  border: 3px solid #4F46E5; /* Highlight selected tile */
Â  Â  Â  Â  Â  Â  transform: scale(1.1);
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  /* --- PLACED TILE STYLES (Allows dragging existing tiles) --- */
Â  Â  Â  Â  .placed-tile {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  opacity: 0.95;
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
Â  Â  Â  Â  Â  Â  cursor: grab;
Â  Â  Â  Â  Â  Â  z-index: 10;
Â  Â  Â  Â  Â  Â  display: grid;
Â  Â  Â  Â  Â  Â  grid-template-columns: var(--tile-grid-template);
Â  Â  Â  Â  Â  Â  grid-template-rows: var(--tile-grid-template);
Â  Â  Â  Â  }
Â  Â  Â  Â  .placed-tile.dragging {
Â  Â  Â  Â  Â  Â  opacity: 0.7;
Â  Â  Â  Â  Â  Â  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
Â  Â  Â  Â  Â  Â  cursor: grabbing;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- GHOST TILE STYLES (Now follows the cursor for continuous placement) --- */
Â  Â  Â  Â  #ghost-tile {
Â  Â  Â  Â  Â  Â  position: fixed; /* Use fixed positioning for reliable cursor following */
Â  Â  Â  Â  Â  Â  pointer-events: none; /* Crucial: allows clicks to pass through to the grid */
Â  Â  Â  Â  Â  Â  opacity: 0.3;
Â  Â  Â  Â  Â  Â  z-index: 50;
Â  Â  Â  Â  Â  Â  display: none; /* Hidden by default */
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 10px rgba(79, 70, 229, 0.8); /* Indigo glow */
Â  Â  Â  Â  Â  Â  border: 1px dashed #4F46E5; /* Dashed indigo border */
Â  Â  Â  Â  }
Â  Â  Â  Â  #ghost-tile.invalid {
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 10px rgba(239, 68, 68, 0.8); /* Red glow for invalid placement */
Â  Â  Â  Â  Â  Â  border: 1px dashed #EF4444; 
Â  Â  Â  Â  Â  Â  opacity: 0.2;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Internal unit squares inside the tile */
Â  Â  Â  Â  .tile-unit-cell {
Â  Â  Â  Â  Â  Â  border: 1px solid rgba(0, 0, 0, 0.4); 
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  /* --- GENERAL UI STYLES --- */
Â  Â  Â  Â  #grid-wrapper {
Â  Â  Â  Â  Â  Â  border-radius: 0; 
Â  Â  Â  Â  Â  Â  transition: box-shadow 0.5s, border-color 0.5s, transform 0.5s; 
Â  Â  Â  Â  }
Â  Â  Â  Â  .bg-white:not(.dialog .bg-white) { 
Â  Â  Â  Â  Â  Â  border-radius: 0; 
Â  Â  Â  Â  }
Â  Â  Â  Â  .dialog .bg-white {
Â  Â  Â  Â  Â  Â  Â border-radius: 0.5rem; 
Â  Â  Â  Â  }

Â  Â  Â  Â  .dialog {
Â  Â  Â  Â  Â  Â  transition: all 0.3s ease-in-out;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- STATUS BAR STYLES (Fixed to prevent height increase) --- */
Â  Â  Â  Â  #status-bar-wrapper {
Â  Â  Â  Â  Â  Â  max-width: 600px;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  margin-bottom: 1.5rem;
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  /* Constrain height when inactive to prevent jumping */
Â  Â  Â  Â  #status-bar {
Â  Â  Â  Â  Â  Â  background-color: transparent;
Â  Â  Â  Â  Â  Â  border-left: none;
Â  Â  Â  Â  Â  Â  padding-top: 0;
Â  Â  Â  Â  Â  Â  padding-bottom: 0;
Â  Â  Â  Â  Â  Â  max-height: 0; /* Starts collapsed */
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  Â  Â  transition: max-height 0.3s ease, padding 0.3s ease, background-color 0.3s ease;
Â  Â  Â  Â  }
Â  Â  Â  Â  #status-bar.active {
Â  Â  Â  Â  Â  Â  max-height: 100px; /* Expands to a visible size */
Â  Â  Â  Â  Â  Â  padding-top: 0.5rem; 
Â  Â  Â  Â  Â  Â  padding-bottom: 0.5rem; 
Â  Â  Â  Â  Â  Â  padding-left: 1rem; 
Â  Â  Â  Â  Â  Â  padding-right: 1rem; 
Â  Â  Â  Â  Â  Â  background-color: #e5e7eb; /* gray-200 */
Â  Â  Â  Â  }
Â  Â  Â  Â  #status-message-content > p {
Â  Â  Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- PULSE ANIMATION FOR SUCCESS --- */
Â  Â  Â  Â  @keyframes scale-pulse {
Â  Â  Â  Â  Â  Â  0% { 
Â  Â  Â  Â  Â  Â  Â  Â  transform: scale(1);
Â  Â  Â  Â  Â  Â  Â  Â  box-shadow: 0 0 10px rgba(74, 222, 128, 0.5), 0 0 20px rgba(16, 185, 129, 0.2); 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  50% { 
Â  Â  Â  Â  Â  Â  Â  Â  transform: scale(0.98); 
Â  Â  Â  Â  Â  Â  Â  Â  box-shadow: 0 0 20px #4ade80, 0 0 40px #10b981; 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  100% { 
Â  Â  Â  Â  Â  Â  Â  Â  transform: scale(1.01); 
Â  Â  Â  Â  Â  Â  Â  Â  box-shadow: 0 0 10px rgba(74, 222, 128, 0.5), 0 0 20px rgba(16, 185, 129, 0.2); 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  .pulse-win {
Â  Â  Â  Â  Â  Â  animation: scale-pulse 1s ease-in-out forwards; 
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Styling for the dialog text */
Â  Â  Â  Â  .success-title {
Â  Â  Â  Â  Â  Â  font-size: 2.5rem; 
Â  Â  Â  Â  Â  Â  line-height: 1.1;
Â  Â  Â  Â  Â  Â  font-weight: 800; 
Â  Â  Â  Â  Â  Â  color: #10B981; 
Â  Â  Â  Â  }
Â  Â  Â  Â  .success-message {
Â  Â  Â  Â  Â  Â  font-size: 1.75rem; 
Â  Â  Â  Â  Â  Â  line-height: 1.2;
Â  Â  Â  Â  Â  Â  color: #374151; 
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  .factor-display {
Â  Â  Â  Â  Â  Â  font-size: 6rem; 
Â  Â  Â  Â  Â  Â  font-weight: 900;
Â  Â  Â  Â  Â  Â  line-height: 1;
Â  Â  Â  Â  Â  Â  color: #4F46E5; 
Â  Â  Â  Â  Â  Â  transition: transform 0.3s;
Â  Â  Â  Â  }

Â  Â  Â  Â  .dialog-tile-visualization {
Â  Â  Â  Â  Â  Â  width: 100px; 
Â  Â  Â  Â  Â  Â  height: 100px;
Â  Â  Â  Â  Â  Â  display: grid;
Â  Â  Â  Â  Â  Â  grid-template-columns: var(--tile-grid-template);
Â  Â  Â  Â  Â  Â  grid-template-rows: var(--tile-grid-template);
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
Â  Â  Â  Â  Â  Â  border: 2px solid #374151;
Â  Â  Â  Â  }
Â  Â  Â  Â  .dialog-tile-visualization .tile-unit-cell {
Â  Â  Â  Â  Â  Â  border: 1px solid rgba(0, 0, 0, 0.4); 
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  /* Responsiveness for the dialog text */
Â  Â  Â  Â  @media (min-width: 640px) { /* sm breakpoint */
Â  Â  Â  Â  Â  Â  .success-title {
Â  Â  Â  Â  Â  Â  Â  Â  font-size: 3rem; 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  .success-message {
Â  Â  Â  Â  Â  Â  Â  Â  font-size: 2.25rem; 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }


Â  Â  Â  Â  /* Media Query for responsiveness */
Â  Â  Â  Â  @media (max-width: 1023px) {
Â  Â  Â  Â  Â  Â  #grid-wrapper {
Â  Â  Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  Â  Â  height: 100vw; 
Â  Â  Â  Â  Â  Â  Â  Â  max-width: 600px;
Â  Â  Â  Â  Â  Â  Â  Â  max-height: 600px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  .grid-container {
Â  Â  Â  Â  Â  Â  Â  Â  grid-template-columns: repeat(12, minmax(0, 1fr));
Â  Â  Â  Â  Â  Â  Â  Â  grid-template-rows: repeat(12, minmax(0, 1fr));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  #status-bar-wrapper {
Â  Â  Â  Â  Â  Â  Â  Â  margin-left: auto;
Â  Â  Â  Â  Â  Â  Â  Â  margin-right: auto;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  </style>
Â  Â  Â  Â  <script type="module">
Â  Â  Â  Â  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
Â  Â  Â  Â  import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
Â  Â  Â  Â  import { getFirestore, doc, setDoc, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
Â  Â  Â  Â  import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";

Â  Â  Â  Â  // Firebase Setup (Required boilerplate for persistence)
Â  Â  Â  Â  const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
Â  Â  Â  Â  const appId = typeof __app_id !== 'undefined' ? __app_id : 'factor-tiling-default';

Â  Â  Â  Â  if (Object.keys(firebaseConfig).length > 0) {
Â  Â  Â  Â  Â  Â  setLogLevel('Debug');
Â  Â  Â  Â  Â  Â  window.app = initializeApp(firebaseConfig);
Â  Â  Â  Â  Â  Â  window.db = getFirestore(window.app);
Â  Â  Â  Â  Â  Â  window.auth = getAuth(window.app);

Â  Â  Â  Â  Â  Â  const signIn = async () => {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (typeof __initial_auth_token !== 'undefined') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await signInWithCustomToken(window.auth, __initial_auth_token);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await signInAnonymously(window.auth);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("Firebase Auth successful.");
Â  Â  Â  Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Firebase Auth failed:", error);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  signIn();
Â  Â  Â  Â  }
Â  Â  </script>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8 flex flex-col items-center font-sans">

Â  Â  <div class="max-w-6xl w-full">
Â  Â  Â  Â  Â  Â  Â  Â  <h1 class="text-5xl sm:text-6xl font-extrabold text-gray-800 mb-2">Factors of 12</h1>
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  <p id="instruction-text" class="text-3xl text-gray-600 mb-2 font-bold">
Â  Â  Â  Â  Â  Â  **Repeat any one type/size of tile to fill the big $12 \times 12$ square without any gaps**
Â  Â  Â  Â  </p>

Â  Â  Â  Â  Â  Â  Â  Â  <div id="status-bar-wrapper" class="lg:w-[600px] mx-auto lg:mx-0">
Â  Â  Â  Â  Â  Â  <div id="status-bar" class="text-lg text-gray-800 font-medium rounded-md">
Â  Â  Â  Â  Â  Â  Â  Â  <div id="status-message-content" class="transition-opacity duration-300 opacity-0 flex justify-between items-center w-full gap-6"></div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  <div class="flex flex-col lg:flex-row gap-8">
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="flex flex-col flex-shrink-0 items-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  Â  Â  Â <div id="grid-wrapper" class="relative w-full lg:w-[600px] lg:h-[600px] shadow-2xl overflow-hidden bg-gray-100 aspect-square">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="tiling-grid" class="grid-container w-full h-full">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="mt-4 flex space-x-4">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="undo-button" class="px-4 py-2 bg-yellow-500 text-white rounded-lg font-semibold transition duration-200 hover:bg-yellow-600 shadow-md text-base disabled:opacity-50 disabled:cursor-not-allowed flex items-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" transform="scale(-1, 1) translate(-20, 0) rotate(90 10 10)"/>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-7-9a1 1 0 011-1h2.586L7.293 8.293a1 1 0 011.414 1.414l-2 2a1 1 0 01-1.414 0l-2-2a1 1 0 010-1.414z" clip-rule="evenodd" transform="translate(0, 0) scale(1, -1) rotate(-90 10 10)"/>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </svg>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Undo Last Move
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="reset-button" class="px-4 py-2 bg-red-200 text-black rounded-lg font-semibold transition duration-200 hover:bg-red-300 shadow-md text-base">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Reset Board
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="flex-grow space-y-6">
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="tile-options-container" class="bg-white p-6 shadow-lg">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <h2 class="text-xl font-semibold text-gray-700 mb-4">Click to Select & Begin Tiling (&larr;)</h2>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="tile-options" class="flex flex-wrap gap-4 justify-center lg:grid lg:grid-cols-2 lg:gap-x-12 lg:gap-y-6">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â  
Â  Â  Â  Â  <div id="ghost-tile"></div>

Â  Â  Â  Â  <div id="game-dialog" class="dialog fixed inset-0 bg-gray-900 bg-opacity-70 z-50 flex items-center justify-center hidden">
Â  Â  Â  Â  <div class="bg-white p-8 shadow-2xl max-w-lg w-full transform scale-90 opacity-0" id="dialog-content-area">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="simple-message-container" class="space-y-4 text-center">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="summary-content" class="space-y-4 pt-6"></div>
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  <button id="dialog-close-button" class="mt-6 w-full px-4 py-2 bg-indigo-600 text-white font-bold hover:bg-indigo-700 transition duration-150">
Â  Â  Â  Â  Â  Â  Â  Â  Play Again
Â  Â  Â  Â  Â  Â  </button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <script type="module">
Â  Â  Â  Â  
Â  Â  Â  Â  function renderMath() {
Â  Â  Â  Â  Â  Â  if (typeof renderMathInElement !== 'undefined') {
Â  Â  Â  Â  Â  Â  Â  Â  renderMathInElement(document.body, {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  delimiters: [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {left: "$$", right: "$$", display: true},
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {left: "$", right: "$", display: false}
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ]
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  const GRID_SIZE = 12; // 12x12 grid
Â  Â  Â  Â  let UNIT_PIXEL_SIZE = 50; 
Â  Â  Â  Â  
Â  Â  Â  Â  const tileSizes = [2, 3, 4, 5, 6, 7, 8];
Â  Â  Â  Â  const factorTiles = [2, 3, 4, 6];
Â  Â  Â  Â  const nonFactorTiles = [5, 7, 8];
Â  Â  Â  Â  const tileColors = {
Â  Â  Â  Â  Â  Â  2: 'bg-green-500', 3: 'bg-orange-500', 4: 'bg-blue-500', 5: 'bg-yellow-500',
Â  Â  Â  Â  Â  Â  6: 'bg-red-500', 7: 'bg-indigo-300', 8: 'bg-pink-300'
Â  Â  Â  Â  };

Â  Â  Â  Â  let currentTileSize = null;
Â  Â  Â  Â  // Stores {x, y, size, element} for easy DOM and physics access
Â  Â  Â  Â  let placedTiles = []; 
Â  Â  Â  Â  // Stores serializable history: [{ x, y, size }]
Â  Â  Â  Â  let history = []; 
Â  Â  Â  Â  const MAX_HISTORY = 30;

Â  Â  Â  Â  let isDragging = false; // True when moving an existing tile OR dragging from source (removed)
Â  Â  Â  Â  let currentDragTile = null; // The element being dragged (placed tile)
Â  Â  Â  Â  let dragOffsetX, dragOffsetY; // Offset from mouse to tile corner

Â  Â  Â  Â  // DOM Elements
Â  Â  Â  Â  const gridWrapper = document.getElementById('grid-wrapper');
Â  Â  Â  Â  const tilingGrid = document.getElementById('tiling-grid');
Â  Â  Â  Â  const tileOptionsContainer = document.getElementById('tile-options-container');
Â  Â  Â  Â  const tileOptionsSource = document.getElementById('tile-options'); 
Â  Â  Â  Â  const statusBar = document.getElementById('status-bar');
Â  Â  Â  Â  const statusMessageContent = document.getElementById('status-message-content');
Â  Â  Â  Â  const resetButton = document.getElementById('reset-button');
Â  Â  Â  Â  const undoButton = document.getElementById('undo-button'); 
Â  Â  Â  Â  const gameDialog = document.getElementById('game-dialog');
Â  Â  Â  Â  const dialogContentArea = document.getElementById('dialog-content-area');
Â  Â  Â  Â  const simpleMessageContainer = document.getElementById('simple-message-container');
Â  Â  Â  Â  const ghostTile = document.getElementById('ghost-tile'); 

Â  Â  Â  Â  // --- Core Utility Functions ---

Â  Â  Â  Â  function calculateUnitSize() {
Â  Â  Â  Â  Â  Â  const rect = tilingGrid.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  UNIT_PIXEL_SIZE = rect.width > 0 ? rect.width / GRID_SIZE : 50;
Â  Â  Â  Â  }

Â  Â  Â  Â  function createTileElement(size, isGhost = false) {
Â  Â  Â  Â  Â  Â  const tileElement = document.createElement('div');
Â  Â  Â  Â  Â  Â  // Re-calculate unit size before creating a tile
Â  Â  Â  Â  Â  Â  calculateUnitSize(); 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // For the ghost tile, we only want the grid lines and dashed border/shadow, not the background color class initially
Â  Â  Â  Â  Â  Â  tileElement.className = `${isGhost ? '' : 'placed-tile'} ${isGhost ? '' : tileColors[size]}`;
Â  Â  Â  Â  Â  Â  tileElement.style.width = `${size * UNIT_PIXEL_SIZE}px`;
Â  Â  Â  Â  Â  Â  tileElement.style.height = `${size * UNIT_PIXEL_SIZE}px`;
Â  Â  Â  Â  Â  Â  tileElement.dataset.size = size;

Â  Â  Â  Â  Â  Â  const gridTemplate = `repeat(${size}, 1fr)`;
Â  Â  Â  Â  Â  Â  tileElement.style.setProperty('--tile-grid-template', gridTemplate);

Â  Â  Â  Â  Â  Â  // Add internal unit cells for visual grid lines
Â  Â  Â  Â  Â  Â  for (let i = 0; i < size * size; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const unitCell = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  // Use 'tile-unit-cell' for internal grid lines on both placed and ghost tiles
Â  Â  Â  Â  Â  Â  Â  Â  unitCell.className = 'tile-unit-cell';
Â  Â  Â  Â  Â  Â  Â  Â  tileElement.appendChild(unitCell);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return tileElement;
Â  Â  Â  Â  }

Â  Â  Â  Â  function initGrid() {
Â  Â  Â  Â  Â  Â  // Clear existing cells, if any (although the grid is mostly for background visual now)
Â  Â  Â  Â  Â  Â  tilingGrid.innerHTML = '';
Â  Â  Â  Â  Â  Â  // Generate grid cells for backdrop
Â  Â  Â  Â  Â  Â  for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const cell = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  cell.className = 'grid-cell';
Â  Â  Â  Â  Â  Â  Â  Â  tilingGrid.appendChild(cell);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Attach the event listener to the grid wrapper for continuous placement
Â  Â  Â  Â  Â  Â  gridWrapper.addEventListener('click', handlePlacementClick);
Â  Â  Â  Â  Â  Â  gridWrapper.addEventListener('mousemove', updateGhostTile);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  generateTileOptions();
Â  Â  Â  Â  Â  Â  resetBoardState();
Â  Â  Â  Â  }

Â  Â  Â  Â  function resetBoardState() {
Â  Â  Â  Â  Â  Â  rebuildGrid([]); // Clears all placed tiles
Â  Â  Â  Â  Â  Â  history = []; Â  Â // Clear history
Â  Â  Â  Â  Â  Â  currentTileSize = null; // Clear selected tile
Â  Â  Â  Â  Â  Â  updateTileOptions(null); 
Â  Â  Â  Â  Â  Â  updateGhostTileContent(null); // Hide ghost tile
Â  Â  Â  Â  Â  Â  updateStatus(); 
Â  Â  Â  Â  Â  Â  hideDialog();
Â  Â  Â  Â  }

Â  Â  Â  Â  function checkOverlap(x, y, size, ignoreElement = null) {
Â  Â  Â  Â  Â  Â  for (const tile of placedTiles) {
Â  Â  Â  Â  Â  Â  Â  Â  if (tile.element === ignoreElement) continue; // Ignore the tile we are moving

Â  Â  Â  Â  Â  Â  Â  Â  // Standard AABB (Axis-Aligned Bounding Box) collision detection
Â  Â  Â  Â  Â  Â  Â  Â  // Collision occurs if the tile is NOT fully outside on all axes
Â  Â  Â  Â  Â  Â  Â  Â  const collision = (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x < tile.x + tile.size && // left edge of new tile is left of right edge of existing tile
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x + size > tile.x && Â  Â  Â // right edge of new tile is right of left edge of existing tile
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y < tile.y + tile.size && // top edge of new tile is above bottom edge of existing tile
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y + size > tile.y Â  Â  Â // bottom edge of new tile is below top edge of existing tile
Â  Â  Â  Â  Â  Â  Â  Â  );

Â  Â  Â  Â  Â  Â  Â  Â  if (collision) return true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }

Â  Â  Â  Â  /**
Â  Â  Â  Â  Â * Finalizes a tile placement and adds it to the placedTiles list.
Â  Â  Â  Â  Â * @param {number} x - Grid X coordinate (0-11).
Â  Â  Â  Â  Â * @param {number} y - Grid Y coordinate (0-11).
Â  Â  Â  Â  Â * @param {number} size - Tile size.
Â  Â  Â  Â  Â * @param {HTMLElement} tileElement - The DOM element.
Â  Â  Â  Â  Â * @param {boolean} pushToHistory - Whether to record this move. Defaults to true.
Â  Â  Â  Â  Â */
Â  Â  Â  Â  function finalizeTilePlacement(x, y, size, tileElement, pushToHistory = true) {
Â  Â  Â  Â  Â  Â  // 1. Set DOM position
Â  Â  Â  Â  Â  Â  tileElement.style.left = `${x * UNIT_PIXEL_SIZE}px`;
Â  Â  Â  Â  Â  Â  tileElement.style.top = `${y * UNIT_PIXEL_SIZE}px`;

Â  Â  Â  Â  Â  Â  // 2. Add to DOM if not already placed
Â  Â  Â  Â  Â  Â  if (!tileElement.parentNode) {
Â  Â  Â  Â  Â  Â  Â  Â  gridWrapper.appendChild(tileElement);
Â  Â  Â  Â  Â  Â  Â  Â  // Add mousedown listener for dragging existing tiles
Â  Â  Â  Â  Â  Â  Â  Â  tileElement.addEventListener('mousedown', startDragPlacedTile);
Â  Â  Â  Â  Â  Â  Â  Â  // Ensure the tile is above the grid but below the ghost
Â  Â  Â  Â  Â  Â  Â  Â  tileElement.style.zIndex = 10;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // 3. Update internal array
Â  Â  Â  Â  Â  Â  const existingTileData = placedTiles.find(t => t.element === tileElement);
Â  Â  Â  Â  Â  Â  if (existingTileData) {
Â  Â  Â  Â  Â  Â  Â  Â  existingTileData.x = x;
Â  Â  Â  Â  Â  Â  Â  Â  existingTileData.y = y;
Â  Â  Â  Â  Â  Â  Â  Â  // Size never changes, but ensure data is correct
Â  Â  Â  Â  Â  Â  Â  Â  existingTileData.size = size;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  placedTiles.push({ x, y, size, element: tileElement });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // 4. Save state
Â  Â  Â  Â  Â  Â  if (pushToHistory) {
Â  Â  Â  Â  Â  Â  Â  Â  pushState();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateStatus();
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  // --- History Management ---

Â  Â  Â  Â  /**
Â  Â  Â  Â  Â * Saves the current grid state to the history stack (x, y, size only).
Â  Â  Â  Â  Â */
Â  Â  Â  Â  function pushState() {
Â  Â  Â  Â  Â  Â  // Serialize placedTiles to a simple array of data objects
Â  Â  Â  Â  Â  Â  const serializableState = placedTiles.map(t => ({ x: t.x, y: t.y, size: t.size }));
Â  Â  Â  Â  Â  Â  // Only push if the state is different from the last one (prevents accidental pushes)
Â  Â  Â  Â  Â  Â  if (history.length === 0 || JSON.stringify(history[history.length - 1]) !== JSON.stringify(serializableState)) {
Â  Â  Â  Â  Â  Â  Â  Â  history.push(serializableState); 

Â  Â  Â  Â  Â  Â  Â  Â  // Enforce max history limit
Â  Â  Â  Â  Â  Â  Â  Â  if (history.length > MAX_HISTORY) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  history.shift(); 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateUndoButtonState();
Â  Â  Â  Â  }

Â  Â  Â  Â  /**
Â  Â  Â  Â  Â * Reverts the grid to the previous state from history.
Â  Â  Â  Â  Â */
Â  Â  Â  Â  function undoLastMove() {
Â  Â  Â  Â  Â  Â  if (history.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  // Pop the *current* state (the one we want to undo)
Â  Â  Â  Â  Â  Â  Â  Â  history.pop();
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Get the state *before* the last move
Â  Â  Â  Â  Â  Â  Â  Â  const previousState = history.length > 0 ? history[history.length - 1] : [];

Â  Â  Â  Â  Â  Â  Â  Â  // Re-render the grid based on the historical state
Â  Â  Â  Â  Â  Â  Â  Â  rebuildGrid(previousState);
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  updateStatus();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateUndoButtonState();
Â  Â  Â  Â  }

Â  Â  Â  Â  /**
Â  Â  Â  Â  Â * Rebuilds the grid from a serialized state array.
Â  Â  Â  Â  Â * @param {Array} state - Array of {x, y, size} objects.
Â  Â  Â  Â  Â */
Â  Â  Â  Â  function rebuildGrid(state) {
Â  Â  Â  Â  Â  Â  // 1. Clear current tiles from DOM
Â  Â  Â  Â  Â  Â  placedTiles.forEach(t => t.element.remove());
Â  Â  Â  Â  Â  Â  placedTiles = [];

Â  Â  Â  Â  Â  Â  // 2. Re-create the DOM elements and the placedTiles array
Â  Â  Â  Â  Â  Â  state.forEach(tileData => {
Â  Â  Â  Â  Â  Â  Â  Â  const newTileElement = createTileElement(tileData.size, false);
Â  Â  Â  Â  Â  Â  Â  Â  // Note: We don't push state here because we are loading from history
Â  Â  Â  Â  Â  Â  Â  Â  finalizeTilePlacement(tileData.x, tileData.y, tileData.size, newTileElement, false); 
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  /**
Â  Â  Â  Â  Â * Enables or disables the undo button based on history.
Â  Â  Â  Â  Â */
Â  Â  Â  Â  function updateUndoButtonState() {
Â  Â  Â  Â  Â  Â  // History check should be against length > 0, because the first state is pushed on first move
Â  Â  Â  Â  Â  Â  undoButton.disabled = history.length <= 0;
Â  Â  Â  Â  Â  Â  if (history.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  undoButton.classList.remove('bg-yellow-500/50');
Â  Â  Â  Â  Â  Â  Â  Â  undoButton.classList.add('bg-yellow-500');
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â undoButton.classList.remove('bg-yellow-500');
Â  Â  Â  Â  Â  Â  Â  Â  undoButton.classList.add('bg-yellow-500/50');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }


Â  Â  Â  Â  // --- Tile Selection and UI Updates ---

Â  Â  Â  Â  function createTileOption(size) {
Â  Â  Â  Â  Â  Â  const wrapper = document.createElement('div');
Â  Â  Â  Â  Â  Â  wrapper.className = 'tile-option-wrapper';

Â  Â  Â  Â  Â  Â  const tile = document.createElement('div');
Â  Â  Â  Â  Â  Â  tile.className = `draggable-tile-source ${tileColors[size]}`;
Â  Â  Â  Â  Â  Â  // Fixed size for the source tiles
Â  Â  Â  Â  Â  Â  tile.style.width = `${50 * size / 2}px`; 
Â  Â  Â  Â  Â  Â  tile.style.height = `${50 * size / 2}px`;
Â  Â  Â  Â  Â  Â  tile.dataset.size = size;

Â  Â  Â  Â  Â  Â  const gridTemplate = `repeat(${size}, 1fr)`;
Â  Â  Â  Â  Â  Â  tile.style.setProperty('--tile-grid-template', gridTemplate);

Â  Â  Â  Â  Â  Â  for (let i = 0; i < size * size; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const unitCell = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  unitCell.className = 'tile-unit-cell';
Â  Â  Â  Â  Â  Â  Â  Â  tile.appendChild(unitCell);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  const label = document.createElement('span');
Â  Â  Â  Â  Â  Â  label.className = 'text-lg font-medium text-gray-700';
Â  Â  Â  Â  Â  Â  label.textContent = `${size}x${size}`;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  wrapper.appendChild(tile);
Â  Â  Â  Â  Â  Â  wrapper.appendChild(label);

Â  Â  Â  Â  Â  Â  // Click event to SELECT the tile (This now enables the ghost tile for placement)
Â  Â  Â  Â  Â  Â  tile.addEventListener('click', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  e.stopPropagation(); 
Â  Â  Â  Â  Â  Â  Â  Â  selectTileSize(size);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // No more mousedown event for dragging from source. Just click to select.

Â  Â  Â  Â  Â  Â  return wrapper;
Â  Â  Â  Â  }

Â  Â  Â  Â  function generateTileOptions() {
Â  Â  Â  Â  Â  Â  tileOptionsSource.innerHTML = '';
Â  Â  Â  Â  Â  Â  tileSizes.forEach(size => {
Â  Â  Â  Â  Â  Â  Â  Â  tileOptionsSource.appendChild(createTileOption(size));
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  function selectTileSize(size) {
Â  Â  Â  Â  Â  Â  // If the same tile is clicked, deselect it (toggle)
Â  Â  Â  Â  Â  Â  if (currentTileSize === size) {
Â  Â  Â  Â  Â  Â  Â  Â  currentTileSize = null;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  currentTileSize = size;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateTileOptions(currentTileSize);
Â  Â  Â  Â  Â  Â  updateGhostTileContent(currentTileSize);
Â  Â  Â  Â  Â  Â  updateStatus();
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateGhostTileContent(size) {
Â  Â  Â  Â  Â  Â  calculateUnitSize(); // Ensure unit size is current

Â  Â  Â  Â  Â  Â  if (!size) {
Â  Â  Â  Â  Â  Â  Â  Â  ghostTile.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // 1. Clear and populate the ghost tile
Â  Â  Â  Â  Â  Â  ghostTile.innerHTML = '';
Â  Â  Â  Â  Â  Â  // Pass size to createTileElement with isGhost=true for correct internal grid
Â  Â  Â  Â  Â  Â  const newGhostContent = createTileElement(size, true); 
Â  Â  Â  Â  Â  Â  ghostTile.appendChild(newGhostContent);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 2. Set the ID and class
Â  Â  Â  Â  Â  Â  ghostTile.id = 'ghost-tile'; // Keep the ID
Â  Â  Â  Â  Â  Â  // Apply the base color class (which has no background, only border/shadow in CSS)
Â  Â  Â  Â  Â  Â  ghostTile.className = tileColors[size]; 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 3. Set dimensions using the calculated UNIT_PIXEL_SIZE
Â  Â  Â  Â  Â  Â  ghostTile.style.width = `${size * UNIT_PIXEL_SIZE}px`;
Â  Â  Â  Â  Â  Â  ghostTile.style.height = `${size * UNIT_PIXEL_SIZE}px`;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 4. Set internal grid template
Â  Â  Â  Â  Â  Â  const gridTemplate = `repeat(${size}, 1fr)`;
Â  Â  Â  Â  Â  Â  ghostTile.style.setProperty('--tile-grid-template', gridTemplate);
Â  Â  Â  Â  }


Â  Â  Â  Â  function updateTileOptions(selectedSize) {
Â  Â  Â  Â  Â  Â  document.querySelectorAll('.draggable-tile-source').forEach(tile => {
Â  Â  Â  Â  Â  Â  Â  Â  const wrapper = tile.closest('.tile-option-wrapper');
Â  Â  Â  Â  Â  Â  Â  Â  const size = parseInt(tile.dataset.size);

Â  Â  Â  Â  Â  Â  Â  Â  // Clear selection state
Â  Â  Â  Â  Â  Â  Â  Â  tile.classList.remove('tile-option-selected');

Â  Â  Â  Â  Â  Â  Â  Â  if (selectedSize !== null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (size === selectedSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile.classList.add('tile-option-selected');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wrapper.classList.remove('tile-option-disabled'); // Selected tile is enabled
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile.style.pointerEvents = 'auto';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Disable non-selected tiles once one is chosen
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wrapper.classList.add('tile-option-disabled');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile.style.pointerEvents = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wrapper.classList.remove('tile-option-disabled');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tile.style.pointerEvents = 'auto';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateStatus() {
Â  Â  Â  Â  Â  Â  if (currentTileSize) {
Â  Â  Â  Â  Â  Â  Â  Â  const tileArea = currentTileSize * currentTileSize;
Â  Â  Â  Â  Â  Â  Â  Â  const totalUnits = GRID_SIZE * GRID_SIZE;
Â  Â  Â  Â  Â  Â  Â  Â  const totalAreaFilled = placedTiles.length * tileArea;
Â  Â  Â  Â  Â  Â  Â  Â  const isFactor = factorTiles.includes(currentTileSize);

Â  Â  Â  Â  Â  Â  Â  Â  const tileInUse = `<span class="text-indigo-600 font-bold">Tile in Use:</span> ${currentTileSize}x${currentTileSize}`;
Â  Â  Â  Â  Â  Â  Â  Â  const tilesPlaced = `<span class="text-indigo-600 font-bold">Tiles Placed:</span> ${placedTiles.length}`;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  let baseMessage = `<p class="flex justify-between w-full">${tileInUse} ${tilesPlaced}</p>`;
Â  Â  Â  Â  Â  Â  Â  Â  let nudgeMessage = '';
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Nudge for being close
Â  Â  Â  Â  Â  Â  Â  Â  if (isFactor && totalAreaFilled / totalUnits >= 0.75 && placedTiles.length < (totalUnits / tileArea)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nudgeMessage = '<p class="text-sm text-green-600 font-semibold text-center mt-1">(You\'re close to finding the factor!)</p>';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Hint for non-factor tiles
Â  Â  Â  Â  Â  Â  Â  Â  const isNonFactor = nonFactorTiles.includes(currentTileSize);
Â  Â  Â  Â  Â  Â  Â  Â  if (isNonFactor && placedTiles.length >= 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nudgeMessage = '<p class="text-sm text-red-500 font-semibold text-center mt-1">(Hint: This tile might not be a perfect fit. Try another size?)</p>';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  statusBar.classList.add('active');
Â  Â  Â  Â  Â  Â  Â  Â  statusMessageContent.innerHTML = baseMessage;
Â  Â  Â  Â  Â  Â  Â  Â  statusMessageContent.classList.remove('opacity-0', 'justify-between');
Â  Â  Â  Â  Â  Â  Â  Â  statusMessageContent.classList.add('flex-col', 'items-start'); // Use flex-col for stacked messages

Â  Â  Â  Â  Â  Â  Â  Â  if (nudgeMessage) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusMessageContent.innerHTML += nudgeMessage;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  statusMessageContent.style.opacity = 1; // Explicitly set opacity
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  statusBar.classList.remove('active');
Â  Â  Â  Â  Â  Â  Â  Â  statusMessageContent.innerHTML = '';
Â  Â  Â  Â  Â  Â  Â  Â  statusMessageContent.style.opacity = 0; // Explicitly set opacity to 0 when inactive
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  checkWinCondition(); // Also check win condition on status update
Â  Â  Â  Â  Â  Â  updateUndoButtonState(); // Update undo state on status refresh
Â  Â  Â  Â  }

Â  Â  Â  Â  function checkWinCondition() {
Â  Â  Â  Â  Â  Â  if (!currentTileSize) return false;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  const tileArea = currentTileSize * currentTileSize;
Â  Â  Â  Â  Â  Â  const totalGridArea = GRID_SIZE * GRID_SIZE;
Â  Â  Â  Â  Â  Â  const requiredTiles = totalGridArea / tileArea;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Check if the number of tiles is mathematically correct AND if all cells are covered
Â  Â  Â  Â  Â  Â  if (placedTiles.length === requiredTiles && totalGridArea % tileArea === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Perform a rigorous check to ensure no overlaps and all cells are covered.
Â  Â  Â  Â  Â  Â  Â  Â  const coveredCells = new Array(totalGridArea).fill(false);
Â  Â  Â  Â  Â  Â  Â  Â  let isPerfectlyCovered = true;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  for(const tile of placedTiles) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let dx = 0; dx < tile.size; dx++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let dy = 0; dy < tile.size; dy++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const index = (tile.y + dy) * GRID_SIZE + (tile.x + dx);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (index >= totalGridArea || coveredCells[index]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Overlap or out of bounds (shouldn't happen with placement check, but good to check)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isPerfectlyCovered = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  coveredCells[index] = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isPerfectlyCovered) break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isPerfectlyCovered) break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  if (isPerfectlyCovered) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  showSuccessDialog();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Optionally disable placement after winning
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Dragging of Existing Tiles ---

Â  Â  Â  Â  function startDragPlacedTile(e) {
Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  currentDragTile = e.currentTarget;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Find the tile data object
Â  Â  Â  Â  Â  Â  const tileData = placedTiles.find(t => t.element === currentDragTile);
Â  Â  Â  Â  Â  Â  if (!tileData) return;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Hide ghost tile while dragging a placed tile
Â  Â  Â  Â  Â  Â  ghostTile.style.display = 'none';

Â  Â  Â  Â  Â  Â  // Calculate offset
Â  Â  Â  Â  Â  Â  const rect = currentDragTile.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  dragOffsetX = e.clientX - rect.left;
Â  Â  Â  Â  Â  Â  dragOffsetY = e.clientY - rect.top;

Â  Â  Â  Â  Â  Â  currentDragTile.classList.add('dragging');
Â  Â  Â  Â  Â  Â  isDragging = true;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  window.addEventListener('mousemove', dragMove);
Â  Â  Â  Â  Â  Â  window.addEventListener('mouseup', dragEnd);
Â  Â  Â  Â  }

Â  Â  Â  Â  function dragMove(e) {
Â  Â  Â  Â  Â  Â  if (!isDragging || !currentDragTile) return;

Â  Â  Â  Â  Â  Â  // Move the tile visually (free movement)
Â  Â  Â  Â  Â  Â  currentDragTile.style.left = `${e.clientX - dragOffsetX - gridWrapper.getBoundingClientRect().left}px`;
Â  Â  Â  Â  Â  Â  currentDragTile.style.top = `${e.clientY - dragOffsetY - gridWrapper.getBoundingClientRect().top}px`;
Â  Â  Â  Â  }

Â  Â  Â  Â  function dragEnd(e) {
Â  Â  Â  Â  Â  Â  if (!isDragging || !currentDragTile) return;

Â  Â  Â  Â  Â  Â  currentDragTile.classList.remove('dragging');
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  const gridRect = tilingGrid.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  const tileData = placedTiles.find(t => t.element === currentDragTile);
Â  Â  Â  Â  Â  Â  const size = parseInt(currentDragTile.dataset.size);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Calculate new snapped position
Â  Â  Â  Â  Â  Â  const relativeX = e.clientX - gridRect.left - dragOffsetX;
Â  Â  Â  Â  Â  Â  const relativeY = e.clientY - gridRect.top - dragOffsetY;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  const unitX = Math.round(relativeX / UNIT_PIXEL_SIZE);
Â  Â  Â  Â  Â  Â  const unitY = Math.round(relativeY / UNIT_PIXEL_SIZE);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Check for bounds and overlap
Â  Â  Â  Â  Â  Â  const outOfBounds = unitX < 0 || unitY < 0 || unitX + size > GRID_SIZE || unitY + size > GRID_SIZE;
Â  Â  Â  Â  Â  Â  const isOverlapped = checkOverlap(unitX, unitY, size, currentDragTile);

Â  Â  Â  Â  Â  Â  if (outOfBounds || isOverlapped) {
Â  Â  Â  Â  Â  Â  Â  Â  // If invalid, return the tile to its old position
Â  Â  Â  Â  Â  Â  Â  Â  if (tileData) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  finalizeTilePlacement(tileData.x, tileData.y, size, currentDragTile, false);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Should not happen for a placed tile, but just in case
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentDragTile.remove();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  // If valid, finalize the move
Â  Â  Â  Â  Â  Â  Â  Â  finalizeTilePlacement(unitX, unitY, size, currentDragTile);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  currentDragTile = null;
Â  Â  Â  Â  Â  Â  isDragging = false;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  window.removeEventListener('mousemove', dragMove);
Â  Â  Â  Â  Â  Â  window.removeEventListener('mouseup', dragEnd);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Ensure ghost tile is visible again if a tile size is selected
Â  Â  Â  Â  Â  Â  if (currentTileSize) {
Â  Â  Â  Â  Â  Â  Â  Â  updateGhostTile(e);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- GHOST TILE AND CONTINUOUS PLACEMENT LOGIC (Updated) ---

Â  Â  Â  Â  let lastSnappedX = -1, lastSnappedY = -1;
Â  Â  Â  Â  
Â  Â  Â  Â  /**
Â  Â  Â  Â  Â * Updates the ghost tile's position based on the cursor and grid.
Â  Â  Â  Â  Â */
Â  Â  Â  Â  function updateGhostTile(e) {
Â  Â  Â  Â  Â  Â  // Only show ghost if a tile is selected AND not dragging a tile already
Â  Â  Â  Â  Â  Â  if (!currentTileSize || isDragging) {
Â  Â  Â  Â  Â  Â  Â  Â  ghostTile.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  lastSnappedX = -1;
Â  Â  Â  Â  Â  Â  Â  Â  lastSnappedY = -1;
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const gridRect = tilingGrid.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Check if the cursor is within the grid's bounding box
Â  Â  Â  Â  Â  Â  const isOverGrid = (
Â  Â  Â  Â  Â  Â  Â  Â  e.clientX >= gridRect.left && e.clientX < gridRect.right &&
Â  Â  Â  Â  Â  Â  Â  Â  e.clientY >= gridRect.top && e.clientY < gridRect.bottom
Â  Â  Â  Â  Â  Â  );

Â  Â  Â  Â  Â  Â  if (isOverGrid) {
Â  Â  Â  Â  Â  Â  Â  Â  ghostTile.style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Calculate position relative to the grid top-left corner
Â  Â  Â  Â  Â  Â  Â  Â  const relativeX = e.clientX - gridRect.left;
Â  Â  Â  Â  Â  Â  Â  Â  const relativeY = e.clientY - gridRect.top;

Â  Â  Â  Â  Â  Â  Â  Â  // Determine the snapped grid unit coordinates (0-11)
Â  Â  Â  Â  Â  Â  Â  Â  const unitX = Math.floor(relativeX / UNIT_PIXEL_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  const unitY = Math.floor(relativeY / UNIT_PIXEL_SIZE);

Â  Â  Â  Â  Â  Â  Â  Â  // Determine the pixel position of the top-left corner of the snapped unit
Â  Â  Â  Â  Â  Â  Â  Â  const snapX = unitX * UNIT_PIXEL_SIZE;
Â  Â  Â  Â  Â  Â  Â  Â  const snapY = unitY * UNIT_PIXEL_SIZE;

Â  Â  Â  Â  Â  Â  Â  Â  const outOfBounds = unitX < 0 || unitY < 0 || unitX + currentTileSize > GRID_SIZE || unitY + currentTileSize > GRID_SIZE;
Â  Â  Â  Â  Â  Â  Â  Â  const isOverlapped = checkOverlap(unitX, unitY, currentTileSize);

Â  Â  Â  Â  Â  Â  Â  Â  if (outOfBounds || isOverlapped) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ghostTile.classList.add('invalid');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastSnappedX = -1; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastSnappedY = -1;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ghostTile.classList.remove('invalid');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Store the valid grid coordinates
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastSnappedX = unitX;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastSnappedY = unitY;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Position the ghost using FIXED coordinates relative to the viewport
Â  Â  Â  Â  Â  Â  Â  Â  ghostTile.style.left = `${gridRect.left + snapX}px`;
Â  Â  Â  Â  Â  Â  Â  Â  ghostTile.style.top = `${gridRect.top + snapY}px`;

Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  // HIDE THE GHOST TILE when outside the grid area
Â  Â  Â  Â  Â  Â  Â  Â  ghostTile.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  lastSnappedX = -1;
Â  Â  Â  Â  Â  Â  Â  Â  lastSnappedY = -1;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  // Placement handler triggered by click on the grid wrapper
Â  Â  Â  Â  function handlePlacementClick(e) {
Â  Â  Â  Â  Â  Â  // Do not allow placement if no tile is selected or currently dragging a tile
Â  Â  Â  Â  Â  Â  if (!currentTileSize || isDragging) return;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Do not place if the click target is an already placed tile (that should be handled by the drag logic) 
Â  Â  Â  Â  Â  Â  if (e.target.closest('.placed-tile')) return;

Â  Â  Â  Â  Â  Â  const isInvalid = ghostTile.classList.contains('invalid');
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Check if the last snapped position was valid
Â  Â  Â  Â  Â  Â  if (isInvalid || lastSnappedX === -1) {
Â  Â  Â  Â  Â  Â  Â  Â  // Flash the grid wrapper for a moment to show placement failed
Â  Â  Â  Â  Â  Â  Â  Â  gridWrapper.style.borderColor = '#EF4444'; // Red
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gridWrapper.style.borderColor = '#374151'; // Original color
Â  Â  Â  Â  Â  Â  Â  Â  }, 200);
Â  Â  Â  Â  Â  Â  Â  Â  return; 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Create and finalize the new tile using the valid snapped coordinates
Â  Â  Â  Â  Â  Â  const newTileElement = createTileElement(currentTileSize, false);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Finalize Placement using the last snapped valid coordinates (unit coords)
Â  Â  Â  Â  Â  Â  finalizeTilePlacement(lastSnappedX, lastSnappedY, currentTileSize, newTileElement);

Â  Â  Â  Â  Â  Â  checkWinCondition();
Â  Â  Â  Â  }


Â  Â  Â  Â  // --- Dialog/Win Logic ---

Â  Â  Â  Â  function showSuccessDialog() {
Â  Â  Â  Â  Â  Â  if (!factorTiles.includes(currentTileSize)) {
Â  Â  Â  Â  Â  Â  Â  Â  // If they somehow tiled with a non-factor due to a bug, show failure
Â  Â  Â  Â  Â  Â  Â  Â  showFailureDialog(false);
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 1. Set the grid/wrapper animation
Â  Â  Â  Â  Â  Â  gridWrapper.classList.add('pulse-win');

Â  Â  Â  Â  Â  Â  // 2. Populate the dialog
Â  Â  Â  Â  Â  Â  const title = `<h2 class="success-title">ðŸŽ‰ Perfect Fit! ðŸŽ‰</h2>`;
Â  Â  Â  Â  Â  Â  const message = `<p class="success-message">The $${currentTileSize} \times ${currentTileSize}$ tile is a **perfect factor** of $12$!</p>`;
Â  Â  Â  Â  Â  Â  const math = `<p class="text-3xl text-gray-700 mt-4">This means $12 \div ${currentTileSize} = ${12 / currentTileSize}$</p>`;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  simpleMessageContainer.innerHTML = title + message + math;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 3. Show dialog
Â  Â  Â  Â  Â  Â  gameDialog.classList.remove('hidden');
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // 4. Animate dialog content
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  dialogContentArea.classList.remove('scale-90', 'opacity-0');
Â  Â  Â  Â  Â  Â  Â  Â  dialogContentArea.classList.add('scale-100', 'opacity-100');
Â  Â  Â  Â  Â  Â  Â  Â  renderMath(); // Re-render math in the dialog
Â  Â  Â  Â  Â  Â  }, 10);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  currentTileSize = null; // Prevent further placement
Â  Â  Â  Â  Â  Â  updateGhostTileContent(null);
Â  Â  Â  Â  Â  Â  updateStatus(); 
Â  Â  Â  Â  }

Â  Â  Â  Â  function hideDialog() {
Â  Â  Â  Â  Â  Â  // Reverse animation
Â  Â  Â  Â  Â  Â  dialogContentArea.classList.add('scale-90', 'opacity-0');
Â  Â  Â  Â  Â  Â  dialogContentArea.classList.remove('scale-100', 'opacity-100');
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Hide after animation
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  gameDialog.classList.add('hidden');
Â  Â  Â  Â  Â  Â  Â  Â  gridWrapper.classList.remove('pulse-win');
Â  Â  Â  Â  Â  Â  }, 300);
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Event Listeners and Initialization ---

Â  Â  Â  Â  resetButton.addEventListener('click', resetBoardState);
Â  Â  Â  Â  undoButton.addEventListener('click', undoLastMove);
Â  Â  Â  Â  document.getElementById('dialog-close-button').addEventListener('click', resetBoardState);
Â  Â  Â  Â  
Â  Â  Â  Â  // Handle window resize for responsiveness
Â  Â  Â  Â  window.addEventListener('resize', () => {
Â  Â  Â  Â  Â  Â  calculateUnitSize();
Â  Â  Â  Â  Â  Â  // Re-render existing tiles to new size
Â  Â  Â  Â  Â  Â  rebuildGrid(placedTiles.map(t => ({ x: t.x, y: t.y, size: t.size })));
Â  Â  Â  Â  Â  Â  // Re-update ghost tile appearance
Â  Â  Â  Â  Â  Â  if (currentTileSize) {
Â  Â  Â  Â  Â  Â  Â  Â  updateGhostTileContent(currentTileSize);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });


Â  Â  Â  Â  document.addEventListener('DOMContentLoaded', initGrid);
Â  Â  </script>
</body>
</html>

