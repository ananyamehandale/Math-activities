<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factors of 12</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- KaTeX CSS and JS for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" xintegrity="sha384-GvrDXHnZaH4W78Q9Rk+B5Wd8JjBwB9Z2Jc0V2YF8g9W9/1aD3UvA0vP4Z2T4" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" xintegrity="sha384-5f5n8pY2h/1aD3UvA0vP4Z2T4" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" xintegrity="sha384-qfX0D/7/0tK2G2F8g9W9/1aD3UvA0vP4Z2T4" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

    <style>
        /* Custom Styles for Grid and Dragging */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(12, 50px);
            grid-template-rows: repeat(12, 50px);
            border: 2px solid #374151;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: relative; /* Ensure tiles position relative to this */
            background-color: white;
        }
        .grid-cell {
            border: 1px solid rgba(100, 100, 100, 0.2);
            box-sizing: border-box;
        }

        /* --- TILE SOURCE STYLES --- */
        .tile-option-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .draggable-tile-source {
            cursor: pointer;
            transition: transform 0.1s ease;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            border: 1px solid rgba(0, 0, 0, 0.1); 
            display: grid; 
            grid-template-columns: var(--tile-grid-template);
            grid-template-rows: var(--tile-grid-template);
        }
        .draggable-tile-source:hover {
            transform: scale(1.05);
        }
        .tile-option-disabled {
            opacity: 0.3;
            cursor: not-allowed !important;
        }
        .tile-option-selected {
            border: 3px solid #4F46E5; 
            transform: scale(1.1);
        }
        
        /* --- PLACED TILE STYLES --- */
        .placed-tile {
            position: absolute;
            opacity: 0.95;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            cursor: grab;
            z-index: 10;
            display: grid;
            grid-template-columns: var(--tile-grid-template);
            grid-template-rows: var(--tile-grid-template);
        }
        .placed-tile.dragging {
            opacity: 0.7;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            cursor: grabbing;
            z-index: 100; /* Dragging tile is highest */
        }

        /* --- GHOST TILE STYLES --- */
        #ghost-tile {
            position: fixed; /* Fixed to viewport for smooth tracking */
            pointer-events: none; /* Crucial: lets clicks pass through to grid */
            opacity: 0.4;
            z-index: 50; /* Above placed tiles (10) but below dialogs */
            display: none; 
            box-shadow: 0 0 15px rgba(79, 70, 229, 0.6); 
            border: 2px dashed #4F46E5; 
        }
        #ghost-tile.invalid {
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.6); 
            border: 2px dashed #EF4444; 
            background-color: rgba(254, 202, 202, 0.5);
            opacity: 0.5;
        }

        .tile-unit-cell {
            border: 1px solid rgba(0, 0, 0, 0.4); 
            box-sizing: border-box;
        }
        
        /* --- GENERAL UI STYLES --- */
        #grid-wrapper {
            border-radius: 0; 
            transition: box-shadow 0.5s, border-color 0.5s, transform 0.5s; 
        }
        .bg-white:not(.dialog .bg-white) { 
            border-radius: 0; 
        }
        .dialog .bg-white {
             border-radius: 0.5rem; 
        }
        .dialog {
            transition: all 0.3s ease-in-out;
            z-index: 200; /* Dialog on top of everything */
        }

        /* --- STATUS BAR STYLES --- */
        #status-bar-wrapper {
            max-width: 600px;
            width: 100%;
            margin-bottom: 1.5rem;
        }
        #status-bar {
            background-color: transparent;
            border-left: none;
            padding-top: 0;
            padding-bottom: 0;
            max-height: 0; 
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease, background-color 0.3s ease;
        }
        #status-bar.active {
            max-height: 100px; 
            padding-top: 0.5rem; 
            padding-bottom: 0.5rem; 
            padding-left: 1rem; 
            padding-right: 1rem; 
            background-color: #e5e7eb; 
        }
        #status-message-content > p {
            margin: 0;
        }

        /* --- PULSE ANIMATION --- */
        @keyframes scale-pulse {
            0% { transform: scale(1); box-shadow: 0 0 10px rgba(74, 222, 128, 0.5); }
            50% { transform: scale(0.98); box-shadow: 0 0 20px #4ade80; }
            100% { transform: scale(1.01); box-shadow: 0 0 10px rgba(74, 222, 128, 0.5); }
        }
        .pulse-win { animation: scale-pulse 1s ease-in-out forwards; }

        /* Dialog Typography */
        .success-title { font-size: 2.5rem; line-height: 1.1; font-weight: 800; color: #10B981; }
        .success-message { font-size: 1.75rem; line-height: 1.2; color: #374151; }
        .factor-display { font-size: 6rem; font-weight: 900; line-height: 1; color: #4F46E5; }
        .dialog-tile-visualization { width: 100px; height: 100px; display: grid; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); border: 2px solid #374151; }
        
        @media (min-width: 640px) { 
            .success-title { font-size: 3rem; }
            .success-message { font-size: 2.25rem; }
        }
        @media (max-width: 1023px) {
            #grid-wrapper { width: 100%; height: 100vw; max-width: 600px; max-height: 600px; }
            .grid-container { grid-template-columns: repeat(12, minmax(0, 1fr)); grid-template-rows: repeat(12, minmax(0, 1fr)); }
            #status-bar-wrapper { margin-left: auto; margin-right: auto; }
        }
    </style>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        if (Object.keys(firebaseConfig).length > 0) {
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            signInAnonymously(auth).catch(console.error);
        }
    </script>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8 flex flex-col items-center font-sans">

    <div class="max-w-6xl w-full">
        <h1 class="text-5xl sm:text-6xl font-extrabold text-gray-800 mb-2">Factors of 12</h1>
        <p id="instruction-text" class="text-xl text-gray-600 mb-2 font-semibold">
            Repeat any one type/size of tile to fill the big $12 \times 12$ square without any gaps
        </p>

        <div id="status-bar-wrapper" class="lg:w-[600px] mx-auto lg:mx-0">
            <div id="status-bar" class="text-lg text-gray-800 font-medium rounded-md">
                <div id="status-message-content" class="transition-opacity duration-300 opacity-0 flex justify-between items-center w-full gap-6"></div>
            </div>
        </div>

        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Left Panel -->
            <div class="flex flex-col flex-shrink-0 items-center">
                 <div id="grid-wrapper" class="relative w-full lg:w-[600px] lg:h-[600px] shadow-2xl overflow-hidden bg-gray-100 aspect-square">
                    <div id="tiling-grid" class="grid-container w-full h-full"></div>
                </div>
                
                <div class="mt-4 flex space-x-4">
                    <button id="undo-button" class="px-4 py-2 bg-yellow-500 text-white rounded-lg font-semibold transition duration-200 hover:bg-yellow-600 shadow-md text-base disabled:opacity-50 disabled:cursor-not-allowed flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" transform="scale(-1, 1) translate(-20, 0) rotate(90 10 10)"/>
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-7-9a1 1 0 011-1h2.586L7.293 8.293a1 1 0 011.414 1.414l-2 2a1 1 0 01-1.414 0l-2-2a1 1 0 010-1.414z" clip-rule="evenodd" transform="translate(0, 0) scale(1, -1) rotate(-90 10 10)"/>
                        </svg>
                        Undo Last Move
                    </button>
                    <button id="reset-button" class="px-4 py-2 bg-red-200 text-black rounded-lg font-semibold transition duration-200 hover:bg-red-300 shadow-md text-base">
                        Reset Board
                    </button>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="flex-grow space-y-6">
                <div id="tile-options-container" class="bg-white p-6 shadow-lg">
                    <h2 class="text-xl font-semibold text-gray-700 mb-4">Click, Drag, and Place in the $12 \times 12$ (&larr;)</h2>
                    <div id="tile-options" class="flex flex-wrap gap-4 justify-center lg:grid lg:grid-cols-2 lg:gap-x-12 lg:gap-y-6"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Ghost Tile Element -->
    <div id="ghost-tile"></div>

    <!-- Dialog -->
    <div id="game-dialog" class="dialog fixed inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center hidden">
        <div class="bg-white p-8 shadow-2xl max-w-lg w-full transform scale-90 opacity-0" id="dialog-content-area">
            <div id="simple-message-container" class="space-y-4 text-center"></div>
            <div id="summary-content" class="space-y-4 pt-6"></div>
            <button id="dialog-close-button" class="mt-6 w-full px-4 py-2 bg-indigo-600 text-white font-bold hover:bg-indigo-700 transition duration-150">Play Again</button>
        </div>
    </div>

    <script type="module">
        function renderMath() {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}]
                });
            }
        }
        
        const GRID_SIZE = 12; 
        let UNIT_PIXEL_SIZE = 50; 
        const tileSizes = [2, 3, 4, 5, 6, 7, 8];
        const factorTiles = [2, 3, 4, 6];
        const nonFactorTiles = [5, 7, 8];
        const tileColors = { 2: 'bg-green-500', 3: 'bg-orange-500', 4: 'bg-blue-500', 5: 'bg-yellow-500', 6: 'bg-red-500', 7: 'bg-indigo-300', 8: 'bg-pink-300' };

        let currentTileSize = null;
        let placedTiles = []; 
        let history = []; 
        const MAX_HISTORY = 30;

        let isDragging = false; 
        let dragOriginIsSource = false; 
        let currentDragTile = null; 
        let dragOffsetX, dragOffsetY; 
        let lastSnappedX = -1, lastSnappedY = -1;
        let ghostModeActive = false; // Default to false (Drag only)

        const gridWrapper = document.getElementById('grid-wrapper');
        const tilingGrid = document.getElementById('tiling-grid');
        const tileOptionsContainer = document.getElementById('tile-options-container');
        const tileOptionsSource = document.getElementById('tile-options'); 
        const statusBar = document.getElementById('status-bar');
        const statusMessageContent = document.getElementById('status-message-content');
        const resetButton = document.getElementById('reset-button');
        const undoButton = document.getElementById('undo-button'); 
        const gameDialog = document.getElementById('game-dialog');
        const dialogContentArea = document.getElementById('dialog-content-area');
        const simpleMessageContainer = document.getElementById('simple-message-container');
        const ghostTile = document.getElementById('ghost-tile'); 

        function calculateUnitSize() {
            const rect = tilingGrid.getBoundingClientRect();
            UNIT_PIXEL_SIZE = rect.width > 0 ? rect.width / GRID_SIZE : 50;
        }

        function createTileElement(size, isGhost = false) {
            const tileElement = document.createElement('div');
            calculateUnitSize(); 
            tileElement.className = `${isGhost ? '' : 'placed-tile'} ${tileColors[size]}`;
            tileElement.style.width = `${size * UNIT_PIXEL_SIZE}px`;
            tileElement.style.height = `${size * UNIT_PIXEL_SIZE}px`;
            tileElement.dataset.size = size;
            tileElement.style.setProperty('--tile-grid-template', `repeat(${size}, 1fr)`);
            for (let i = 0; i < size * size; i++) {
                const unitCell = document.createElement('div');
                unitCell.className = 'tile-unit-cell';
                tileElement.appendChild(unitCell);
            }
            return tileElement;
        }

        function pushState() {
            const serializableState = placedTiles.map(t => ({ x: t.x, y: t.y, size: t.size }));
            if (history.length === 0 || JSON.stringify(history[history.length - 1]) !== JSON.stringify(serializableState)) {
                history.push(serializableState); 
                if (history.length > MAX_HISTORY) history.shift(); 
            }
            updateUndoButtonState();
        }

        function undoLastMove() {
            if (history.length > 0) {
                history.pop();
                const previousState = history.length > 0 ? history[history.length - 1] : [];
                rebuildGrid(previousState);
                updateStatus();
            }
            updateUndoButtonState();
        }

        function rebuildGrid(state) {
            placedTiles.forEach(t => t.element.remove());
            placedTiles = [];
            state.forEach(tileData => {
                const newTileElement = createTileElement(tileData.size, false);
                finalizeTilePlacement(tileData.x, tileData.y, tileData.size, newTileElement, false); 
            });
        }
        
        function updateUndoButtonState() {
            undoButton.disabled = history.length <= 0;
            if (history.length > 0) {
                undoButton.classList.remove('bg-yellow-500/50');
                undoButton.classList.add('bg-yellow-500');
            } else {
                 undoButton.classList.remove('bg-yellow-500');
                undoButton.classList.add('bg-yellow-500/50');
            }
        }

        // --- Toggle Ghost Mode ---
        function toggleGhostMode(e) {
            if (!currentTileSize) return;
            ghostModeActive = !ghostModeActive;
            // Pass the mouse event to immediately update position/visibility
            updateGhostTile(e); 
            updateStatus(); 
        }
        
        function deselectTile() {
            currentTileSize = null;
            ghostModeActive = false;
            updateTileOptions(null);
            updateGhostTileContent(null);
            updateStatus();
            ghostTile.style.display = 'none';
            lastSnappedX = -1;
            lastSnappedY = -1;
        }

        function createTileOption(size) {
            const wrapper = document.createElement('div');
            wrapper.className = 'tile-option-wrapper';
            const tile = document.createElement('div');
            tile.className = `draggable-tile-source ${tileColors[size]}`;
            tile.style.width = `${50 * size / 2}px`; 
            tile.style.height = `${50 * size / 2}px`;
            tile.dataset.size = size;
            tile.style.setProperty('--tile-grid-template', `repeat(${size}, 1fr)`);
            for (let i = 0; i < size * size; i++) {
                const unitCell = document.createElement('div');
                unitCell.className = 'tile-unit-cell';
                tile.appendChild(unitCell);
            }
            const label = document.createElement('span');
            label.className = 'text-lg font-medium text-gray-700';
            label.textContent = `${size}x${size}`;
            wrapper.appendChild(tile);
            wrapper.appendChild(label);
            
            tile.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                if (currentTileSize === size) {
                    deselectTile();
                } else {
                    selectTileSize(size); 
                }
            });
            tile.addEventListener('mousedown', (e) => startDragFromSource(e, size));
            return wrapper;
        }

        function generateTileOptions() {
            tileOptionsSource.innerHTML = '';
            tileSizes.forEach(size => tileOptionsSource.appendChild(createTileOption(size)));
        }
        
        function selectTileSize(size) {
            if (currentTileSize !== size) {
                currentTileSize = size;
                ghostModeActive = false; // Reset ghost mode on new selection
                updateTileOptions(size);
                updateGhostTileContent(size);
                updateStatus();
            }
        }

        function updateGhostTileContent(size) {
            calculateUnitSize(); 
            if (!size) { ghostTile.style.display = 'none'; return; }
            ghostTile.innerHTML = '';
            const newGhostContent = createTileElement(size, true); 
            ghostTile.appendChild(newGhostContent);
            ghostTile.id = 'ghost-tile'; 
            ghostTile.className = tileColors[size]; 
            ghostTile.style.width = `${size * UNIT_PIXEL_SIZE}px`;
            ghostTile.style.height = `${size * UNIT_PIXEL_SIZE}px`;
            ghostTile.style.setProperty('--tile-grid-template', `repeat(${size}, 1fr)`);
        }

        function updateTileOptions(selectedSize) {
            const hasPlacedTiles = placedTiles.length > 0;
            document.querySelectorAll('.draggable-tile-source').forEach(tile => {
                const wrapper = tile.closest('.tile-option-wrapper');
                const size = parseInt(tile.dataset.size);
                tile.classList.remove('tile-option-selected');
                if (selectedSize !== null && hasPlacedTiles) {
                    if (size === selectedSize) tile.classList.add('tile-option-selected');
                    else { wrapper.classList.add('tile-option-disabled'); tile.style.pointerEvents = 'none'; }
                } else if (selectedSize !== null && size === selectedSize) {
                     tile.classList.add('tile-option-selected');
                     wrapper.classList.remove('tile-option-disabled');
                     tile.style.pointerEvents = 'auto';
                } else {
                    wrapper.classList.remove('tile-option-disabled');
                    tile.style.pointerEvents = 'auto';
                }
            });
        }

        function updateStatus() {
            if (currentTileSize) {
                const tileArea = currentTileSize * currentTileSize;
                const totalUnits = GRID_SIZE * GRID_SIZE;
                const totalAreaFilled = placedTiles.length * tileArea;
                const isFactor = factorTiles.includes(currentTileSize);
                const tileInUse = `<span class="text-indigo-600 font-bold">Tile in Use:</span> ${currentTileSize}x${currentTileSize}`;
                const tilesPlaced = `<span class="text-indigo-600 font-bold">Tiles Placed:</span> ${placedTiles.length}`;
                
                const rightClickHint = ghostModeActive 
                    ? `<span class="text-sm text-blue-600 font-bold ml-2 self-center">(Right-click to stop quick fill)</span>`
                    : `<span class="text-sm text-gray-500 font-normal ml-2 self-center">(Right-click for quick fill)</span>`;

                let baseMessage = `<p class="flex justify-between w-full">${tileInUse} ${tilesPlaced} ${rightClickHint}</p>`;
                let nudgeMessage = '';
                
                if (isFactor && totalAreaFilled / totalUnits >= 0.75 && placedTiles.length < (totalUnits / tileArea)) nudgeMessage = '<p class="text-sm text-green-600 font-semibold text-center mt-1">(You\'re close to finding the factor!)</p>';
                const isNonFactor = nonFactorTiles.includes(currentTileSize);
                if (isNonFactor && placedTiles.length >= 2) nudgeMessage = '<p class="text-sm text-red-500 font-semibold text-center mt-1">(Hint: This tile might not be a perfect fit. Try another size?)</p>';
                
                statusBar.classList.add('active');
                statusMessageContent.innerHTML = baseMessage;
                statusMessageContent.classList.remove('opacity-0', 'justify-between');
                statusMessageContent.classList.add('flex-col', 'items-start'); 
                if (nudgeMessage) statusMessageContent.innerHTML += nudgeMessage;
                statusMessageContent.style.opacity = 1; 
            } else {
                statusBar.classList.remove('active');
                statusMessageContent.innerHTML = '';
                statusMessageContent.style.opacity = 0; 
                ghostTile.style.display = 'none'; 
            }
            updateUndoButtonState(); 
        }

        function checkOverlap(x, y, size) {
            return placedTiles.some(tile => {
                if (currentDragTile && tile.element === currentDragTile) return false;
                const xOverlap = Math.max(0, Math.min(x + size, tile.x + tile.size) - Math.max(x, tile.x));
                const yOverlap = Math.max(0, Math.min(y + size, tile.y + tile.size) - Math.max(y, tile.y));
                return xOverlap > 0 && yOverlap > 0;
            });
        }

        function updateGhostTile(e) {
            // Only show ghost if tile selected, NOT dragging, AND ghost mode is ACTIVE
            if (!currentTileSize || isDragging || !ghostModeActive) {
                ghostTile.style.display = 'none';
                lastSnappedX = -1; lastSnappedY = -1;
                return;
            }
            const gridRect = tilingGrid.getBoundingClientRect();
            const isOverGrid = (e.clientX >= gridRect.left && e.clientX < gridRect.right && e.clientY >= gridRect.top && e.clientY < gridRect.bottom);

            if (isOverGrid) {
                ghostTile.style.display = 'block';
                const relativeX = e.clientX - gridRect.left;
                const relativeY = e.clientY - gridRect.top;
                const unitX = Math.floor(relativeX / UNIT_PIXEL_SIZE);
                const unitY = Math.floor(relativeY / UNIT_PIXEL_SIZE);
                const snapX = unitX * UNIT_PIXEL_SIZE;
                const snapY = unitY * UNIT_PIXEL_SIZE;
                const outOfBounds = unitX < 0 || unitY < 0 || unitX + currentTileSize > GRID_SIZE || unitY + currentTileSize > GRID_SIZE;
                const isOverlapped = checkOverlap(unitX, unitY, currentTileSize);

                if (outOfBounds || isOverlapped) {
                    ghostTile.classList.add('invalid');
                    lastSnappedX = -1; lastSnappedY = -1;
                } else {
                    ghostTile.classList.remove('invalid');
                    lastSnappedX = unitX; lastSnappedY = unitY;
                }
                ghostTile.style.left = `${gridRect.left + snapX}px`;
                ghostTile.style.top = `${gridRect.top + snapY}px`;
            } else {
                ghostTile.style.display = 'none';
                lastSnappedX = -1; lastSnappedY = -1;
            }
        }
        
        function handlePlacementClick(e) {
            // Only allow placement if ghost mode is ACTIVE
            if (!currentTileSize || isDragging || !ghostModeActive) return;

            if (e.target.closest('.placed-tile')) return;
            
            const isInvalid = ghostTile.classList.contains('invalid');
            if (isInvalid || lastSnappedX === -1) {
                gridWrapper.style.borderColor = '#EF4444'; 
                setTimeout(() => { gridWrapper.style.borderColor = '#374151'; }, 200);
                return; 
            }
            pushState();
            const newTileElement = createTileElement(currentTileSize, false);
            finalizeTilePlacement(lastSnappedX, lastSnappedY, currentTileSize, newTileElement);
            checkWinCondition();
        }

        function startDragFromSource(e, size) {
            e.preventDefault(); e.stopPropagation();
            selectTileSize(size); 
            currentDragTile = createTileElement(size, false);
            currentDragTile.classList.add('dragging');
            currentDragTile.style.position = 'absolute';
            document.body.appendChild(currentDragTile);
            const tileRect = e.currentTarget.getBoundingClientRect();
            const sourceTileUnitSize = tileRect.width / size; 
            const factor = UNIT_PIXEL_SIZE / sourceTileUnitSize;
            dragOffsetX = (e.clientX - tileRect.left) * factor;
            dragOffsetY = (e.clientY - tileRect.top) * factor;
            isDragging = true;
            dragOriginIsSource = true;
            ghostTile.style.display = 'none'; 
            setupGlobalDragEvents();
        }

        function startDragFromBoard(e, tileData) {
            e.preventDefault(); e.stopPropagation(); 
            ghostTile.style.display = 'none'; 
            if (currentTileSize === null || currentTileSize !== tileData.size) selectTileSize(tileData.size);
            placedTiles = placedTiles.filter(t => t !== tileData);
            calculateUnitSize();
            const rect = tileData.element.getBoundingClientRect();
            tileData.element.remove();
            document.body.appendChild(tileData.element);
            currentDragTile = tileData.element;
            currentDragTile.classList.add('dragging');
            currentDragTile.style.position = 'absolute';
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            isDragging = true;
            dragOriginIsSource = false; 
            pushState(); 
            setupGlobalDragEvents();
        }

        function onMouseMove(e) {
            if (isDragging && currentDragTile) {
                currentDragTile.style.left = `${e.clientX - dragOffsetX}px`;
                currentDragTile.style.top = `${e.clientY - dragOffsetY}px`;
                const size = parseInt(currentDragTile.dataset.size);
                const gridRect = tilingGrid.getBoundingClientRect();
                if (e.clientX > gridRect.left && e.clientX < gridRect.right && e.clientY > gridRect.top && e.clientY < gridRect.bottom) {
                    const relativeX = e.clientX - dragOffsetX - gridRect.left + (UNIT_PIXEL_SIZE/2); 
                    const relativeY = e.clientY - dragOffsetY - gridRect.top + (UNIT_PIXEL_SIZE/2);
                    const unitX = Math.floor(relativeX / UNIT_PIXEL_SIZE);
                    const unitY = Math.floor(relativeY / UNIT_PIXEL_SIZE);
                    const outOfBounds = unitX < 0 || unitY < 0 || unitX + size > GRID_SIZE || unitY + size > GRID_SIZE;
                    const isOverlapped = checkOverlap(unitX, unitY, size);
                    if (outOfBounds || isOverlapped) currentDragTile.classList.add('invalid');
                    else currentDragTile.classList.remove('invalid');
                } else {
                     currentDragTile.classList.add('invalid'); 
                }
            } else {
                updateGhostTile(e); 
            }
        }

        function onMouseUp(e) {
            if (!isDragging || !currentDragTile) return;
            isDragging = false;
            currentDragTile.classList.remove('dragging');
            const size = parseInt(currentDragTile.dataset.size);
            const gridRect = gridWrapper.getBoundingClientRect();
            const tileRect = currentDragTile.getBoundingClientRect();
            const binRect = tileOptionsContainer.getBoundingClientRect(); 

            const droppedInBin = (tileRect.right > binRect.left && tileRect.left < binRect.right && tileRect.bottom > binRect.top && tileRect.top < binRect.bottom);
            const isOverGridArea = (tileRect.left >= gridRect.left - (size*UNIT_PIXEL_SIZE/2) && tileRect.right <= gridRect.right + (size*UNIT_PIXEL_SIZE/2) && tileRect.top >= gridRect.top - (size*UNIT_PIXEL_SIZE/2) && tileRect.bottom <= gridRect.bottom + (size*UNIT_PIXEL_SIZE/2));

            if (droppedInBin || !isOverGridArea) {
                currentDragTile.remove();
                if (!dragOriginIsSource) {
                    if (placedTiles.length === 0) {
                        deselectTile(); 
                    }
                    updateStatus();
                } else if (dragOriginIsSource) {
                    if (placedTiles.length === 0) {
                         deselectTile(); 
                    }
                }
            } else {
                handleDrop(size);
            }
            currentDragTile = null;
            dragOriginIsSource = false;
            removeGlobalDragEvents();
            updateStatus();
            updateGhostTile(e);
        }
        
        function handleDrop(size) {
            const gridRect = tilingGrid.getBoundingClientRect();
            const tileRect = currentDragTile.getBoundingClientRect();
            const relativeX = tileRect.left - gridRect.left;
            const relativeY = tileRect.top - gridRect.top;
            const unitX = Math.round(relativeX / UNIT_PIXEL_SIZE);
            const unitY = Math.round(relativeY / UNIT_PIXEL_SIZE);
            const snapX = unitX * UNIT_PIXEL_SIZE;
            const snapY = unitY * UNIT_PIXEL_SIZE;

            if (unitX < 0 || unitY < 0 || unitX + size > GRID_SIZE || unitY + size > GRID_SIZE) {
                currentDragTile.remove();
                if (!dragOriginIsSource) undoLastMove();
                return; 
            }
            if (checkOverlap(unitX, unitY, size)) {
                currentDragTile.remove();
                if (!dragOriginIsSource) undoLastMove();
                return; 
            }
            finalizeTilePlacement(unitX, unitY, size, currentDragTile, snapX, snapY, false); 
            if (dragOriginIsSource) {
                pushState();
                checkWinCondition();
            }
        }
        
        function finalizeTilePlacement(x, y, size, element, snapX = x * UNIT_PIXEL_SIZE, snapY = y * UNIT_PIXEL_SIZE, shouldPushState = true) {
            element.remove(); 
            gridWrapper.appendChild(element); 
            element.style.left = `${snapX}px`;
            element.style.top = `${snapY}px`;
            element.style.position = 'absolute';
            const tileData = { x, y, size, element, isPlaced: true }; 
            placedTiles.push(tileData);
            element.removeEventListener('mousedown', element.dragListener); 
            element.dragListener = (e) => startDragFromBoard(e, tileData);
            element.addEventListener('mousedown', element.dragListener);
            if (shouldPushState) pushState();
            updateTileOptions(currentTileSize); 
            updateStatus();
        }
        
        function checkWinCondition() {
            const totalUnits = GRID_SIZE * GRID_SIZE; 
            const tileArea = currentTileSize * currentTileSize;
            if (factorTiles.includes(currentTileSize) && (totalUnits % tileArea === 0)) {
                 const requiredTiles = totalUnits / tileArea;
                if (placedTiles.length === requiredTiles) {
                    gridWrapper.classList.add('pulse-win'); 
                    resetButton.disabled = true;
                    undoButton.disabled = true; 
                    ghostTile.style.display = 'none';
                    setTimeout(() => {
                        gridWrapper.classList.remove('pulse-win'); 
                        showSummaryDialog(true);
                    }, 1000); 
                }
            } 
        }

        function setupGlobalDragEvents() {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function removeGlobalDragEvents() {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }

        function hideDialog() {
            gridWrapper.classList.remove('pulse-win'); 
            resetButton.disabled = false;
            updateUndoButtonState(); 
            if (currentTileSize) updateGhostTileContent(currentTileSize);
            dialogContentArea.classList.add('scale-90', 'opacity-0');
            setTimeout(() => { gameDialog.classList.add('hidden'); }, 300);
        }

        function createDialogTileVisual(size) {
            const tileColor = tileColors[size];
            const tileVisual = document.createElement('div');
            tileVisual.className = `dialog-tile-visualization ${tileColor} mx-auto`;
            const gridTemplate = `repeat(${size}, 1fr)`;
            tileVisual.style.setProperty('--tile-grid-template', gridTemplate);
            for (let i = 0; i < size * size; i++) {
                const unitCell = document.createElement('div');
                unitCell.className = 'tile-unit-cell';
                tileVisual.appendChild(unitCell);
            }
            return tileVisual.outerHTML;
        }

        function showSummaryDialog(success, sizeAttempted = null) {
            gridWrapper.classList.remove('pulse-win'); 
            resetButton.disabled = false; 
            dialogContentArea.classList.add('scale-90', 'opacity-0');
            gameDialog.classList.remove('hidden');
            const size = currentTileSize || sizeAttempted;
            const tileText = `${size}x${size}`;
            document.getElementById('summary-content').innerHTML = '';
            document.getElementById('dialog-close-button').style.display = 'none'; 
            ghostTile.style.display = 'none';

            if (success) {
                const tileVisualHTML = createDialogTileVisual(size);
                simpleMessageContainer.innerHTML = `
                    <p class="success-title">Amazing Job!</p>
                    <div class="flex flex-col items-center gap-4 py-4 border-y border-green-200">
                        ${tileVisualHTML}
                        <span class="factor-display">${size}</span>
                        <p class="text-xl font-semibold text-gray-700">is a factor of 12!</p>
                    </div>
                    <p class="success-message text-xl mt-4">You perfectly tiled the $12 \\times 12$ square using the ${tileText} tile.</p>
                `;
                document.getElementById('summary-content').innerHTML = `
                    <div class="flex gap-4 pt-4"> 
                        <button id="btn-back" class="flex-1 px-4 py-2 bg-gray-500 text-white font-bold rounded-lg hover:bg-gray-600 transition duration-150">Back to View</button>
                        <button id="btn-next" class="flex-1 px-4 py-2 bg-indigo-600 text-white font-bold rounded-lg hover:bg-indigo-700 transition duration-150">Next</button>
                    </div>
                `;
                setTimeout(() => {
                    document.getElementById('btn-back').onclick = hideDialog;
                    document.getElementById('btn-next').onclick = () => { hideDialog(); resetGame(true); };
                }, 10);
            } else {
                simpleMessageContainer.innerHTML = `
                    <h3 class="text-2xl font-bold text-gray-800 mb-2">Factors of 12: Conclusion</h3>
                    <p class="text-gray-600">You were attempting to tile with ${tileText} tiles. Since the $12 \\times 12$ square could not be perfectly tiled, let's look at the math!</p>
                `;
                document.getElementById('summary-content').innerHTML = `
                    <h4 class="text-lg font-semibold text-indigo-700">Mathematical Conclusion:</h4>
                    <p class="text-gray-700">A square tile $N \\times N$ can only tile an $M \\times M$ square perfectly if $N$ is a factor of $M$.</p>
                    <ul class="list-disc list-inside text-gray-700 space-y-2 ml-4">
                        <li>**Factors of 12 (Perfect Fit):** Square tiles with side lengths **2, 3, 4, and 6**.</li>
                        <li>**Non-Factors (Leaves Remainder):** Square tiles with side lengths **5, 7, and 8**. (e.g., $12 \\pmod {5} = 2$ units left over)</li>
                    </ul>
                `;
                document.getElementById('dialog-close-button').style.display = 'block';
                document.getElementById('dialog-close-button').textContent = 'Start New Attempt';
                document.getElementById('dialog-close-button').onclick = () => { hideDialog(); resetGame(true); };
            }
            setTimeout(() => { dialogContentArea.classList.remove('scale-90', 'opacity-0'); renderMath(); }, 10);
        }

        function resetGame(skipSummaryCheck = false) {
            const wasNonFactorAttempt = !skipSummaryCheck && currentTileSize !== null && nonFactorTiles.includes(currentTileSize) && placedTiles.length > 0;
            const sizeAttempted = currentTileSize;
            currentTileSize = null;
            placedTiles.forEach(t => t.element.remove());
            placedTiles = [];
            history = []; 
            ghostModeActive = false;
            initGrid();
            generateTileOptions();
            updateTileOptions(null);
            updateGhostTileContent(null); 
            updateStatus();
            if (wasNonFactorAttempt) showSummaryDialog(false, sizeAttempted);
        }
        
        window.addEventListener('resize', () => {
            calculateUnitSize(); 
            placedTiles.forEach(tileData => {
                 // Update placed tile dimensions
                 tileData.element.style.width = `${tileData.size * UNIT_PIXEL_SIZE}px`;
                 tileData.element.style.height = `${tileData.size * UNIT_PIXEL_SIZE}px`;
                 tileData.element.style.left = `${tileData.x * UNIT_PIXEL_SIZE}px`;
                 tileData.element.style.top = `${tileData.y * UNIT_PIXEL_SIZE}px`;
            });
            if (currentTileSize) updateGhostTileContent(currentTileSize);
            renderMath();
        });

        window.onload = () => {
            initGrid();
            generateTileOptions();
            updateStatus();
            resetButton.addEventListener('click', () => resetGame(false)); 
            undoButton.addEventListener('click', undoLastMove); 
            updateUndoButtonState(); 
            document.addEventListener('mousemove', onMouseMove); 
            document.addEventListener('mouseup', onMouseUp); 
            gridWrapper.addEventListener('click', handlePlacementClick);
            gridWrapper.addEventListener('contextmenu', (e) => { e.preventDefault(); toggleGhostMode(e); }); 
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') deselectTile();
            });
            
            renderMath();
        };
        
        function initGrid() {
            calculateUnitSize();
            Array.from(gridWrapper.querySelectorAll('.placed-tile')).forEach(el => el.remove());
            if (tilingGrid.children.length === 0) {
                 for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    tilingGrid.appendChild(cell);
                }
            }
        }
    </script>
</body>
</html>
